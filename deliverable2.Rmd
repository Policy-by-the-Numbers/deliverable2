---
title: "Cluster Analysis of Country Data"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
# clean memory
rm(list = ls())

# reading in data via Github link
file <-("https://github.com/Policy-by-the-Numbers/deliverable2/raw/main/deli2dataset.csv")
data <-read.csv(file)

# reset indexes to R paradigm
row.names(data)=NULL

#check data types
str(data)

```
```{r}
# Preparing data

# I think we want to keep all of these variables but the name
clusterData=data[,c(2:10)]

#save the country names as the row index
row.names(clusterData)=data$name

clusterData
```


```{r}
# computing distance matrix

set.seed(999)
```

```{r}
library(cluster)
distanceMatrix=daisy(x=clusterData, metric = "gower")
```
```{r}
projectedData = cmdscale(distanceMatrix, k=2)
```

```{r}
# save coordinates to original data frame:
data$dim1 = projectedData[,1]
data$dim2 = projectedData[,2]

# see some:

data[,c('dim1','dim2')][1:10,]
```

```{r}
library(ggplot2)
base= ggplot(data=data,
             aes(x=dim1, y=dim2,
                 label=name)) 
base + geom_text(size=2)
```

```{r}
# prepare hierarchical cluster
hc = hclust(distanceMatrix)
# very simple dendrogram
plot(hc,hang = -1,cex=0.5)
```

```{r}
# Computing clusters
library(factoextra)


```

```{r}
# Hierarchical (agglomerative) method:

fviz_nbclust(clusterData, 
             hcut,
             diss=distanceMatrix,
             method = "gap_stat",
             k.max = 10,
             verbose = F,
             hc_func = "agnes")
```

```{r}
# Hierarchical (divisive) method:
fviz_nbclust(clusterData, 
             hcut,
             diss=distanceMatrix,
             method = "gap_stat",
             k.max = 10,
             verbose = F,
             hc_func = "diana")
```

2. Computing Clusters
```{r}
# Computing clusters:

NumberDesiredClusters=3 #both methods had 3 as optimal no. of clusters

# Hierarchical - agglom:
res.agnes= hcut(distanceMatrix, 
                k = NumberDesiredClusters,
                isdiss=TRUE,
                hc_func='agnes',
                hc_method = "ward.D2")

# Hierarchical - divisive:
res.diana= hcut(distanceMatrix, 
                k = NumberDesiredClusters,
                isdiss=TRUE,
                hc_func='diana',
                hc_method = "ward.D2")

```

3. Results from Clustering
```{r}
# Results from Clustering

# Saving results to original dataframe
data$agn=as.factor(res.agnes$cluster)
data$dia=as.factor(res.diana$cluster)
```

```{r}
# verify ordinality in clusters

 #aggregate(data=fromPy,
         #Overallscore~agn,
          #UN=mean)

##aggregate(data=fromPy,
           #Overallscore~dia,
            #UN=mean)

# this part is confusing to me
# may not be necessary for this dataset?
```
4. Evaluating Results
```{r}
# Plot silhouettes
# agglom silh
fviz_silhouette(res.agnes)

```
```{r}
# divisive silh
fviz_silhouette(res.diana)
```

```{r}
# detecting cases wrongly clustered

#saving individual silhouettes
agnEval=data.frame(res.agnes$silinfo$widths)
diaEval=data.frame(res.diana$silinfo$widths)

agnPoor=rownames(agnEval[agnEval$sil_width<0,])
diaPoor=rownames(diaEval[diaEval$sil_width<0,])
```

```{r}
# now seeing which countries are not well clustered
library("qpcR") 
bad_Clus=as.data.frame(qpcR:::cbind.na(sort(agnPoor),
                                       sort(diaPoor)))
names(bad_Clus)=c("agn","dia")
bad_Clus
```
How to compare clustering?
```{r}
# hierarchical agglom:
base= ggplot(data=data,
             aes(x=dim1, y=dim2,
                 label=name)) 
agnPlot=base + labs(title = "AGNES") + geom_point(size=2,
                                              aes(color=agn),
                                              show.legend = T)


# hierarchical diana:
diaPlot=base + labs(title = "DIANA") + geom_point(size=2,
                                              aes(color=dia),
                                              show.legend = T) 

# compare visually:
library(ggpubr)

ggarrange(agnPlot, diaPlot,ncol = 2,common.legend = T)

```

Producing dendograms for the results
```{r}
# Agglomerative
fviz_dend(res.agnes,
          k=NumberDesiredClusters,
          cex = 0.45, 
          horiz = T,
          main = "AGNES approach")
```

```{r}
# Divisive approach:
fviz_dend(res.diana,
          k=NumberDesiredClusters,
          cex = 0.45, 
          horiz = T,
          main = "DIANA approach")
```





Ok I actually wnted to do factor analysis so I am doing that here


FACTOR ANALYSIS

1. Subset original data frame
```{r}
FAdata=clusterData

```

2. Compute correlations
```{r}
library(polycor)
corMatrix=polycor::hetcor(FAdata)$correlations

# visualizing matrix
library(ggcorrplot)

ggcorrplot(corMatrix,
           type = "lower") + 
          theme(axis.text.x  = element_text(size = 5),
                axis.text.y  = element_text(size = 5))

# looks terrible tbh
```

3. check conditions

```{r}
# the amount of data should be enough for the correlation process:
library(psych)
psych::KMO(corMatrix)

# need more/better data to do factor analysis
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
